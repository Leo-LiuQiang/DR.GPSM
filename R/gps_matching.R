#' GPS-matching ATE estimator  (numeric-column interface)
#'
#' @param data      Data frame pre-processed by \code{gps_pre_process()}
#' @param treatment Column index of the treatment variable
#' @param outcome   Column index of the outcome variable
#' @param pred      K × n cross-fitted residual matrix from the outcome model
#' @param contrast  C(K, 2) × K contrast matrix generated by \code{build_contrast()}
#' @param nboot     Number of bootstrap replications (default = 500)
#'
#' @return A list with components:
#' \describe{
#'   \item{estimate}{Named numeric vector of estimated ATEs for each contrast}
#'   \item{ci_lower}{Named numeric vector of lower 95% confidence bounds}
#'   \item{ci_upper}{Named numeric vector of upper 95% confidence bounds}
#' }
#' @export
gps_matching <- function(data,
                 treatment,
                 outcome,
                 pred,
                 contrast,
                 nboot){

  n <- nrow(data)
  tlevel <- levels(as.factor(data[, treatment]))
  K <- length(tlevel)

  loggps_cols <- integer(K - 1L)
  for (k in 2:K) {
    need <- paste0("loggps_", tlevel[k])
    idx  <- match(need, names(data))
    if (is.na(idx))
      stop(sprintf("Can't find loggps %s (please make sure gps_pre_process worked)", need))
    loggps_cols[k - 1L] <- idx
  }

  index <- vector("list", K)
  mat   <- vector("list", K)

  for (i in seq_len(K)) {
    index[[i]] <- which(data[, treatment] == tlevel[i])
    mat[[i]] <- as.matrix(data[index[[i]], loggps_cols, drop = FALSE])
  }

  M_ID <- array(NA_integer_, dim = c(n, K))
  for (i in seq_len(K))
    for (j in seq_len(K)) {
      if (i == j) {
        M_ID[index[[i]], j] <- index[[i]]
      } else {
        nn <- RANN::nn2(mat[[j]], mat[[i]], k = 1,
                        treetype = "kd", searchtype = "priority")$nn.idx
        M_ID[index[[i]], j] <- index[[j]][nn]
      }
    }

  tau <- matrix(0, nrow = nrow(contrast), ncol = n)
  for (ii in c(1: nrow(contrast))){
    for (i in c(1: n)){
      j <- which(M_ID[i, ] == i)
      if (contrast[ii, j] == -1){
        k <- which(contrast[ii, ] == 1)
        tau[ii, M_ID[i, k]] = tau[ii, M_ID[i, k]] + data[M_ID[i, k], outcome] - pred[k, M_ID[i, k]]
        tau[ii, M_ID[i, j]] = tau[ii, M_ID[i, j]] - data[M_ID[i, j], outcome] + pred[k, M_ID[i, j]]
      }
      if (contrast[ii, j] == 1){
        k <- which(contrast[ii, ] == -1)
        tau[ii, M_ID[i, k]] = tau[ii, M_ID[i, k]] - data[M_ID[i, k], outcome] + pred[k, M_ID[i, k]]
        tau[ii, M_ID[i, j]] = tau[ii, M_ID[i, j]] + data[M_ID[i, j], outcome] - pred[k, M_ID[i, j]]
      }
      if (contrast[ii, j] == 0){
        k1 <- which(contrast[ii, ] == -1)
        k2 <- which(contrast[ii, ] == 1)
        tau[ii, M_ID[i, k2]] = tau[ii, M_ID[i, k2]] + data[M_ID[i, k2], outcome] - pred[k2, M_ID[i, k2]]
        tau[ii, M_ID[i, k1]] = tau[ii, M_ID[i, k1]] - data[M_ID[i, k1], outcome] + pred[k1, M_ID[i, k1]]
        tau[ii, M_ID[i, j]] = tau[ii, M_ID[i, j]] - pred[k1, M_ID[i, j]] + pred[k2, M_ID[i, j]]
      }
    }
  }

  est = apply(tau, 1, mean)
  tau = tau - est

  btstrp = matrix(nrow = nboot, ncol = nrow(contrast))
  for (i in c(1: nboot)){
    w = c(stats::rmultinom(1, 2*n, rep(1/n, n)))
    btstrp[i, ] = apply(w * tau, 1, sum) / (2*n)
  }

  cilower <- -apply(btstrp, 2, function(y) stats::quantile(y, 0.975)) + est
  ciupper <- -apply(btstrp, 2, function(y) stats::quantile(y, 0.025)) + est

  out <- list(
    estimate = stats::setNames(as.numeric(est),rownames(contrast)),
    ci_lower = stats::setNames(as.numeric(cilower),rownames(contrast)),
    ci_upper = stats::setNames(as.numeric(ciupper),rownames(contrast))
  )
  return(out)
}
